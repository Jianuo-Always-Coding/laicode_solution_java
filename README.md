# [Binary Search](https://github.com/Jianuo-Always-Coding/laicode_solution_java/tree/main/BinarySearch/)

This part contains the problems which can use binary search to solve to optimize time complexity from O(n) to O(logn).

Binary search always solve problems with 2 conditions such sorted array and find a arget number.

# [Linked List](https://github.com/Jianuo-Always-Coding/laicode_solution_java/tree/main/LinkedList/)

This part contains the problems which is related to a new class List Node. This part can do **mergeSortLinkedList** and **CheckIfLinkedListIsPalindrome** to review.

```java
class ListNode {
    public int value;
    public ListNode next;
    public ListNode(int value) {
        this.value = value;
        next = null;
    }
}

```

The key point of this part including

- find mid node
- reverse a Linked List
- combine two Linked List

# [Recursion](https://github.com/Jianuo-Always-Coding/laicode_solution_java/tree/main/Recursion/)

This part contains some problems which can be solved with recursion, including some sort algorithms, such as **Selection Sort, Merge Sort** and **Quick Sort**. Notably, tail recursion can be converted into iteration.

# [Deque, Stack and Queue](https://github.com/Jianuo-Always-Coding/laicode_solution_java/tree/main/DequeAndQueue/)

Complete the solution with Stack, Queue and Deque, including some Object-oriented Design for Stack, Queue and Deque.

# [Binary Tree and Binary Search Tree](https://github.com/Jianuo-Always-Coding/laicode_solution_java/tree/main/BinaryTreeAndBinarySearchTree/)

- A **binary tree** is a tree which at most has 2 branches
- A **balanced binary tree** is a tree that the difference height of left tree and right tree is less or equal to 1.
- A **complete binary tree** is a tree that only the last layer has null value, and no number after null.

- A **binary Search tree** is a tree like binary search. All the nodes in the left tree are smaller than root, and all the nodes in the right tree are greater than root.
